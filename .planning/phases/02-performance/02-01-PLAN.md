---
phase: 02-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: []
autonomous: true
user_setup: []

must_haves:
  truths:
    - All 16 RLS policies use (select auth.uid()) subquery pattern
    - auth.uid() is no longer called directly in any RLS policy
    - RLS policies using public.current_app_role() also use subquery pattern
  artifacts:
    - path: ".planning/phases/02-performance/02-01-rls-optimization.sql"
      provides: "Migration script with optimized RLS policies"
      contains: "CREATE POLICY"
  key_links:
    - from: "RLS policies"
      to: "PostgreSQL initPlan optimization"
      via: "Subquery wrapping of volatile functions"
      pattern: "\\(select\\s+auth\\.uid\\(\\)\\)"
---

<objective>
Optimize all 16 RLS policies to use `(select auth.uid())` subquery pattern instead of direct `auth.uid()` calls

Purpose: Enable PostgreSQL's `initPlan` optimization which caches the auth.uid() result instead of calling it on every row, providing 10-100x performance improvement on RLS queries
Output: Migration script with all RLS policies recreated using subquery pattern
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-performance/02-CONTEXT.md
@.planning/phases/02-performance/02-RESEARCH.md
@docs/10-database-security-model.md
@.planning/phases/01-critical-security/01-02-SUMMARY.md
@.planning/phases/01-critical-security/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Query current RLS policies from database</name>
  <files>None (query via MCP Supabase)</files>
  <action>
    Use mcp__supabase__executeSQL to query pg_policies system view:

    SELECT
      schemaname,
      tablename,
      policyname,
      cmd,
      qual,
      with_check
    FROM pg_policies
    WHERE schemaname = 'public'
    ORDER BY tablename, policyname;

    This catalog will show:
    - All 16 RLS policies across tables: boys, settings, user_roles, invite_codes, audit_logs
    - Current USING (qual) and WITH CHECK expressions
    - Which policies use auth.uid() directly vs. subquery pattern
    - Which policies use public.current_app_role() or public.can_access_audit_logs()

    Save the results to 02-01-rls-optimization.sql as a comment block for reference.
  </action>
  <verify>Query returns 16 policies from pg_policies view; results saved to migration file</verify>
  <done>Complete catalog of all RLS policies with their expressions documented</done>
</task>

<task type="auto">
  <name>Create migration to optimize RLS policies with subquery pattern</name>
  <files>.planning/phases/02-performance/02-01-rls-optimization.sql</files>
  <action>
    Create migration file 02-01-rls-optimization.sql that drops and recreates each RLS policy with the subquery optimization pattern.

    For each policy identified in Task 1:

    1. If policy uses auth.uid() directly:
       BEFORE: auth.uid()::text = uid
       AFTER: (select auth.uid())::text = uid

    2. If policy uses public.current_app_role() directly:
       BEFORE: public.current_app_role() IN ('officer','captain','admin')
       AFTER: (select public.current_app_role()) IN ('officer','captain','admin')

    3. If policy uses public.can_access_audit_logs():
       BEFORE: public.can_access_audit_logs()
       AFTER: (select public.can_access_audit_logs())

    Pattern per table (example for boys):
    BEGIN;
    DROP POLICY IF EXISTS boys_select_officer_plus ON public.boys;
    CREATE POLICY boys_select_officer_plus
    ON public.boys
    FOR SELECT
    TO authenticated
    USING ((select public.current_app_role()) IN ('officer','captain','admin'));
    COMMIT;

    Apply this to all 16 policies across: boys (4), settings (3), user_roles (5), invite_codes (3), audit_logs (1).

    DO NOT wrap entire expressions - only wrap the volatile function call:
    - WRONG: (select auth.uid()::text = uid)
    - RIGHT: (select auth.uid())::text = uid

    Reference docs/10-database-security-model.md for target policy definitions.
  </action>
  <verify>Migration file contains DROP + CREATE for all 16 policies; each volatile function wrapped in (select ...)</verify>
  <done>Complete migration script ready for database execution</done>
</task>

<task type="auto">
  <name>Apply RLS optimization migration to database</name>
  <files>.planning/phases/02-performance/02-01-rls-optimization.sql</files>
  <action>
    Use mcp__supabase__executeSQL to execute the migration file 02-01-rls-optimization.sql against the remote database.

    Execute the entire migration file content via MCP tool.

    After execution, verify policies were updated:
    SELECT policyname, qual, with_check
    FROM pg_policies
    WHERE schemaname = 'public'
    ORDER BY tablename, policyname;

    Check that all policies now contain "(select auth.uid())" or "(select public.current_app_role())" patterns.
  </action>
  <verify>All 16 policies updated in database; pg_policies shows subquery pattern in expressions</verify>
  <done>RLS policies optimized with initPlan caching enabled</done>
</task>

</tasks>

<verification>
After completion, verify:
1. All 16 RLS policies exist in pg_policies (no policies were dropped during migration)
2. Every auth.uid() reference is wrapped in (select ...)
3. Every public.current_app_role() reference is wrapped in (select ...)
4. Every public.can_access_audit_logs() reference is wrapped in (select ...)
5. No entire expressions are wrapped (only function calls)
</verification>

<success_criteria>
1. All 16 RLS policies use (select auth.uid()) subquery pattern instead of direct auth.uid()
2. PostgreSQL initPlan optimization is now enabled for all RLS queries
3. Migration file is preserved for rollback if needed
</success_criteria>

<output>
After completion, create `.planning/phases/02-performance/02-01-SUMMARY.md`
</output>
