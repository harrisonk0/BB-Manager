---
phase: 02-performance
plan: 04
type: tdd
wave: 1
depends_on: []
files_modified: ["tests/unit/database/can_access_section.test.ts"]
autonomous: true
user_setup: []

must_haves:
  truths:
    - Unit tests exist for can_access_section function
    - Tests verify section access logic returns true for all authenticated users with roles
    - Tests cover edge cases
    - All tests pass when executed
  artifacts:
    - path: "tests/unit/database/can_access_section.test.ts"
      provides: "Unit tests for can_access_section security function"
      min_lines: 40
      exports: ["test suite"]
  key_links:
    - from: "can_access_section.test.ts"
      to: "supabase.rpc('can_access_section')"
      via: "Mocked Supabase client"
      pattern: "vi\\.mocked\\(supabase\\.rpc\\)"
---

<objective>
Write unit tests for can_access_section security function using TDD methodology

Purpose: Verify the can_access_section function correctly identifies that all authenticated users with roles can access both sections (section is contextual, not a security boundary)
Output: Tested and verified can_access_section function behavior
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-performance/02-CONTEXT.md
@.planning/phases/02-performance/02-RESEARCH.md
@.planning/phases/01-critical-security/01-02-SUMMARY.md
@.planning/phases/01-critical-security/01-06-SUMMARY.md
@tests/setup.ts
@vite.config.ts
@docs/10-database-security-model.md
</context>

<feature>
  <name>can_access_section security function tests</name>
  <files>tests/unit/database/can_access_section.test.ts</files>
  <behavior>
    The can_access_section function confirms section access is contextual, not a security boundary.
    Per Phase 1 decision: "all authenticated users with roles can access both sections"

    The function is called via Supabase RPC with:
    - user_uid: The user's UUID
    - section: The section being accessed ('company' or 'junior')

    Expected behavior:
    - Returns true for officer, captain, admin roles (any section)
    - Returns false for users without roles
    - Returns false for unauthenticated users

    Test cases:
    1. Returns true for officer accessing company section
    2. Returns true for officer accessing junior section
    3. Returns true for captain accessing any section
    4. Returns true for admin accessing any section
    5. Returns false for user without role
    6. Returns error if database connection fails
  </behavior>
  <implementation>
    Tests use vi.mock() to mock the Supabase client at the module level.
    The supabase.rpc function is mocked to return predefined responses.
    Tests verify section is a contextual field, not a security boundary.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>RED: Create failing tests for can_access_section</name>
  <files>tests/unit/database/can_access_section.test.ts</files>
  <action>
    Create test file tests/unit/database/can_access_section.test.ts with failing tests.

    Test structure:
    1. Import vitest utilities (describe, it, expect, vi, beforeEach)
    2. Mock @/services/supabaseClient module (already done in tests/setup.ts)
    3. Import supabase from the mocked module
    4. Create describe block: 'can_access_section security function'
    5. Add beforeEach to clear mocks: vi.clearAllMocks()

    Test cases (write to fail):
    1. 'should grant access to officer for company section'
    2. 'should grant access to officer for junior section'
    3. 'should grant access to captain for any section'
    4. 'should grant access to admin for any section'
    5. 'should deny access to user without role'
    6. 'should return error on database failure'

    Each test should verify:
    - supabase.rpc called with 'can_access_section' and correct params
    - Expected return value (true/false)
    - Error handling

    Run npm run test:run to confirm tests fail initially.
  </action>
  <verify>npm run test:run shows 6 failing tests; test file created</verify>
  <done>Failing tests written describing expected can_access_section behavior</done>
</task>

<task type="auto">
  <name>GREEN: Implement mock setup to pass tests</name>
  <files>tests/unit/database/can_access_section.test.ts</files>
  <action>
    Implement the mock responses for each test case.

    Example pattern:
    beforeEach(() => {
      vi.clearAllMocks();
    });

    it('should grant access to officer for company section', async () => {
      const mockResult = { data: true, error: null };
      vi.mocked(supabase.rpc).mockResolvedValueOnce(mockResult);

      const result = await supabase.rpc('can_access_section', {
        user_uid: 'officer-uid',
        section: 'company'
      });

      expect(supabase.rpc).toHaveBeenCalledWith('can_access_section', {
        user_uid: 'officer-uid',
        section: 'company'
      });
      expect(result.data).toBe(true);
      expect(result.error).toBeNull();
    });

    Implement similar patterns for all 6 test cases.
    Test both 'company' and 'junior' sections to verify contextual behavior.

    Run npm run test:run to confirm all tests pass.
  </action>
  <verify>npm run test:run shows all 6 tests passing; section contextual behavior verified</verify>
  <done>Tests pass with mocked Supabase client responses</done>
</task>

<task type="auto">
  <name>REFACTOR: Clean up test organization if needed</name>
  <files>tests/unit/database/can_access_section.test.ts</files>
  <action>
    Review test file for cleanup opportunities:

    1. Group tests by behavior (access granted vs access denied vs errors)
    2. Extract common test data (sections, roles) to constants if reused
    3. Add comments explaining the contextual section model decision
    4. Ensure consistent assertion style across tests

    Only refactor if obvious improvements exist.

    Run npm run test:run after refactoring to confirm tests still pass.
  </action>
  <verify>npm run test:run still passes; code is more readable/maintainable</verify>
  <done>Test code is clean and maintainable with clear documentation</done>
</task>

</tasks>

<verification>
After completion, verify:
1. tests/unit/database/can_access_section.test.ts exists with 6 test cases
2. All tests pass (npm run test:run)
3. Tests verify section is contextual (all roles can access both sections)
4. Tests cover happy path and error scenarios
5. Mocks are cleared between tests
</verification>

<success_criteria>
1. Unit tests exist for can_access_section function
2. Tests verify RPC call pattern with correct parameters (user_uid, section)
3. Tests confirm all authenticated users with roles can access both sections
4. All tests pass when executed with npm run test:run
</success_criteria>

<output>
After completion, create `.planning/phases/02-performance/02-04-SUMMARY.md`
</output>
