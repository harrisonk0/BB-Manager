# 9. Database, Migrations, and Access Control

This repo uses Supabase Postgres as the system of record. Database structure and permissions
are managed as SQL migrations.

## Source of Truth

- `supabase/migrations/` is the authoritative history of database structure and permissions
  (tables, indexes, constraints, GRANTs, and any future RLS policies).
- Baseline migrations (`supabase/migrations/*_remote_schema.sql`) were generated by pulling the
  existing remote database schema. Treat these files as immutable history.
  - Do not edit, squash, reorder, or delete baseline migrations (even if they appear redundant).

## How Schema Changes Are Made

All database changes must be done via **new** migration files under `supabase/migrations/`.
This includes:

- Schema changes (tables/columns/indexes/constraints)
- Permission changes (GRANT/REVOKE)
- Future security hardening (RLS enablement and policies)

> TODO: Add a dedicated runbook for the expected Supabase CLI workflow in this repo (local dev,
> migration creation, review, and safe rollout).

## Baseline vs Future Migrations

- **Baseline (`*_remote_schema.sql`)**: a snapshot of the remote database at the time it was
  captured. It reflects historical UI-driven changes and is kept to preserve history and enable
  reproducible environments.
- **Future migrations**: incremental, reviewed changes applied on top of the baseline from this
  point forward.

Practically: never “refactor” or “clean up” the baseline; add a new migration that moves the
schema forward.

## Current Access Model (and Risks)

The current database access model is primarily **GRANT-based** (table-level permissions).
The baseline migrations include GRANT statements for Supabase roles (for example `anon` and
`authenticated`) and do **not** enable or define Row Level Security (RLS) policies for the
application tables.

Security implications:

- The browser ships a public anon key; client-side role checks are **not** a security boundary.
- Without RLS, the database does not enforce row-level rules such as:
  - per-user access
  - role-based restrictions (admin/captain/officer)
  - section isolation (`company` vs `junior`)
- Treat the current model as security-incomplete until RLS hardening is implemented.

> TODO: RLS hardening: enable RLS and add policies via new migrations, then validate the app
> end-to-end against those policies.
> TODO: Review baseline GRANTs and tighten toward least privilege (especially for `anon`).
> TODO: Document an explicit per-table access matrix (who can read/write what, and why).
