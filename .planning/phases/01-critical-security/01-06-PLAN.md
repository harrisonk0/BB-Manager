---
phase: 01-critical-security
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - vite.config.ts
  - tests/setup.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Vitest is installed as dev dependency"
    - "npm run test executes vitest successfully"
    - "Vitest configuration is integrated with vite.config.ts"
    - "Test setup file exists for global mocks"
  artifacts:
    - path: "package.json"
      provides: "npm test script"
      contains: "\"test\": \"vitest\""
    - path: "vite.config.ts"
      provides: "Vitest configuration"
      contains: "/// <reference types=\"vitest/config\" />"
    - path: "tests/setup.ts"
      provides: "Test setup file"
      min_lines: 1
  key_links:
    - from: "npm run test"
      to: "vitest"
      via: "package.json scripts"
      pattern: "vitest"
---

<objective>
Set up Vitest testing framework with TypeScript configuration

Purpose: Vitest is the de facto standard test framework for Vite projects. It provides native TypeScript support, fast test execution, and configuration sharing with Vite. This plan installs Vitest, configures it to work with the existing Vite config, and creates a basic test setup file for future test files.

Output: Working Vitest setup with TypeScript support
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/01-critical-security/01-RESEARCH.md
@package.json
@vite.config.ts
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Install Vitest and dependencies</name>
  <files>package.json</files>
  <action>
    Run: npm install -D vitest @vitest/ui

    This installs:
    - vitest: The test framework
    - @vitest/ui: Optional UI for viewing test results

    Why: Vitest is the standard test runner for Vite projects. It provides native ESM support, TypeScript out of the box, and shares configuration with vite.config.ts. The @vitest/ui package adds an optional but helpful test UI for development.

    Note: Using -D flag installs as devDependency (appropriate for test tools).
  </action>
  <verify>grep -q "vitest" /Users/harrisonk/dev/BB-Manager/package.json</verify>
  <done>vitest and @vitest/ui are in package.json devDependencies</done>
</task>

<task type="auto">
  <name>Add test scripts to package.json</name>
  <files>package.json</files>
  <action>
    Add the following scripts to the "scripts" object in package.json:

    ```json
    "test": "vitest",
    "test:run": "vitest run",
    "test:coverage": "vitest run --coverage"
    ```

    Remove or keep any existing scripts - ensure these new scripts are added.

    Why: Standard test scripts provide consistent commands for running tests. "test" runs in watch mode (for development), "test:run" runs once (for CI), "test:coverage" generates coverage reports (future use).

    Current package.json scripts section should be updated to include these test commands.
  </action>
  <verify>grep -q "\"test\": \"vitest\"" /Users/harrisonk/dev/BB-Manager/package.json</verify>
  <done>Test scripts exist in package.json</done>
</task>

<task type="auto">
  <name>Configure Vitest in vite.config.ts</name>
  <files>vite.config.ts</files>
  <action>
    1. Add the TypeScript reference comment at the top of the file:
       /// <reference types="vitest/config" />

    2. Add a test configuration object to the defineConfig export:
       ```typescript
       test: {
         globals: true,
         environment: 'node',
         setupFiles: ['./tests/setup.ts'],
         include: ['**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
         exclude: ['node_modules', 'dist', '.supabase'],
       }
       ```

    The full export should look like:
    ```typescript
    export default defineConfig({
      build: { outDir: 'dist' },
      server: { port: 3000, host: '0.0.0.0', historyApiFallback: true },
      plugins: [dyadComponentTagger(), react()],
      define: {},
      resolve: { alias: { '@': path.resolve(__dirname, '.') } },
      test: {
        globals: true,
        environment: 'node',
        setupFiles: ['./tests/setup.ts'],
        include: ['**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
        exclude: ['node_modules', 'dist', '.supabase'],
      },
    });
    ```

    Why: Adding vitest config to vite.config.ts allows sharing aliases and other configuration. The reference comment enables TypeScript autocomplete for vitest config options. 'node' environment is appropriate for testing services (no DOM needed yet).

    Note: Environment will change to 'happy-dom' when React component testing is added (future phases).
  </action>
  <verify>grep -q "test:" /Users/harrisonk/dev/BB-Manager/vite.config.ts && grep -q "vitest/config" /Users/harrisonk/dev/BB-Manager/vite.config.ts</verify>
  <done>Vitest configuration exists in vite.config.ts with TypeScript reference</done>
</task>

<task type="auto">
  <name>Create test setup file</name>
  <files>tests/setup.ts</files>
  <action>
    Create the tests directory and setup.ts file:

    ```bash
    mkdir -p tests
    ```

    Create tests/setup.ts with content:
    ```typescript
    // Test setup file for Vitest
    // Global mocks and test utilities go here

    import { vi } from 'vitest';

    // Mock Supabase client for service-layer tests
    // This will be expanded when actual tests are written
    vi.mock('@/services/supabaseClient', () => ({
      supabase: {
        from: vi.fn(),
        rpc: vi.fn(),
      },
    }));
    ```

    Why: The setup file runs before each test file and is used for global mocks and configuration. Mocking the Supabase client prevents actual database calls during unit tests of service functions.

    Note: This is a minimal setup. Additional mocks will be added as tests are written in Phase 2 and beyond.
  </action>
  <verify>ls -la /Users/harrisonk/dev/BB-Manager/tests/setup.ts</verify>
  <done>tests/setup.ts file exists with Supabase client mock</done>
</task>

<task type="auto">
  <name>Create placeholder test file and verify Vitest runs</name>
  <files>tests/example.test.ts</files>
  <action>
    Create tests/example.test.ts with a basic test:

    ```typescript
    import { describe, it, expect } from 'vitest';

    describe('Vitest setup verification', () => {
      it('should run a basic test', () => {
        expect(1 + 1).toBe(2);
      });
    });
    ```

    Run: npm run test:run

    Expected output: Tests pass with 1 passing test.

    Why: A basic test confirms the Vitest installation and configuration are working correctly. This provides a smoke test for the testing infrastructure before real tests are added in Phase 2.

    Note: This placeholder test can be removed when real tests are added.
  </action>
  <verify>npm run test:run</verify>
  <done>Vitest runs successfully with passing tests</done>
</task>

</tasks>

<verification>
1. grep -q "vitest" package.json
2. grep -q "\"test\": \"vitest\"" package.json
3. grep -q "vitest/config" vite.config.ts
4. grep -q "test:" vite.config.ts
5. ls -la tests/setup.ts
6. npm run test:run executes successfully
</verification>

<success_criteria>
1. Vitest installed in devDependencies
2. Test scripts (test, test:run, test:coverage) in package.json
3. Vitest configuration in vite.config.ts
4. Test setup file exists at tests/setup.ts
5. npm run test:run executes successfully
6. Placeholder test passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-critical-security/01-06-SUMMARY.md`
</output>
