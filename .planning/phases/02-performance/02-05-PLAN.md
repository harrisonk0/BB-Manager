---
phase: 02-performance
plan: 05
type: tdd
wave: 1
depends_on: []
files_modified: ["tests/unit/database/can_access_audit_logs.test.ts"]
autonomous: true
user_setup: []

must_haves:
  truths:
    - Unit tests exist for can_access_audit_logs function
    - Tests verify captain and admin roles can access audit logs
    - Tests verify officer role cannot access audit logs
    - All tests pass when executed
  artifacts:
    - path: "tests/unit/database/can_access_audit_logs.test.ts"
      provides: "Unit tests for can_access_audit_logs security function"
      min_lines: 50
      exports: ["test suite"]
  key_links:
    - from: "can_access_audit_logs.test.ts"
      to: "supabase.rpc('can_access_audit_logs')"
      via: "Mocked Supabase client"
      pattern: "vi\\.mocked\\(supabase\\.rpc\\)"
---

<objective>
Write unit tests for can_access_audit_logs security function using TDD methodology

Purpose: Verify the can_access_audit_logs function correctly restricts audit log access to Captain and Admin roles only (per security model)
Output: Tested and verified can_access_audit_logs function behavior
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-performance/02-CONTEXT.md
@.planning/phases/02-performance/02-RESEARCH.md
@.planning/phases/01-critical-security/01-02-SUMMARY.md
@.planning/phases/01-critical-security/01-06-SUMMARY.md
@tests/setup.ts
@vite.config.ts
@docs/10-database-security-model.md
</context>

<feature>
  <name>can_access_audit_logs security function tests</name>
  <files>tests/unit/database/can_access_audit_logs.test.ts</files>
  <behavior>
    The can_access_audit_logs function enforces audit log access restrictions per the security model:
    - Captain role: can access audit logs (true)
    - Admin role: can access audit logs (true)
    - Officer role: CANNOT access audit logs (false)
    - Users without roles: CANNOT access audit logs (false)

    Per Phase 1 decision: "Audit log access restricted to Captain/Admin only via can_access_audit_logs() function"

    The function is called via Supabase RPC with:
    - user_uid: The user's UUID

    Expected behavior:
    - Returns true for captain role
    - Returns true for admin role
    - Returns false for officer role
    - Returns false for users without roles

    Test cases:
    1. Returns true for captain role
    2. Returns true for admin role
    3. Returns false for officer role (access denied)
    4. Returns false for user without role (access denied)
    5. Returns error if database connection fails
  </behavior>
  <implementation>
    Tests use vi.mock() to mock the Supabase client at the module level.
    The supabase.rpc function is mocked to return predefined responses.
    Tests verify the security boundary: only Captain and Admin can access audit logs.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>RED: Create failing tests for can_access_audit_logs</name>
  <files>tests/unit/database/can_access_audit_logs.test.ts</files>
  <action>
    Create test file tests/unit/database/can_access_audit_logs.test.ts with failing tests.

    Test structure:
    1. Import vitest utilities (describe, it, expect, vi, beforeEach)
    2. Mock @/services/supabaseClient module (already done in tests/setup.ts)
    3. Import supabase from the mocked module
    4. Create describe block: 'can_access_audit_logs security function'
    5. Add beforeEach to clear mocks: vi.clearAllMocks()

    Test cases (write to fail):
    1. 'should grant access to captain role'
    2. 'should grant access to admin role'
    3. 'should deny access to officer role'
    4. 'should deny access to user without role'
    5. 'should return error on database failure'

    Each test should verify:
    - supabase.rpc called with 'can_access_audit_logs' and user_uid param
    - Expected return value (true for captain/admin, false for others)
    - Error handling

    Run npm run test:run to confirm tests fail initially.
  </action>
  <verify>npm run test:run shows 5 failing tests; test file created</verify>
  <done>Failing tests written describing expected can_access_audit_logs behavior</done>
</task>

<task type="auto">
  <name>GREEN: Implement mock setup to pass tests</name>
  <files>tests/unit/database/can_access_audit_logs.test.ts</files>
  <action>
    Implement the mock responses for each test case.

    Example pattern:
    beforeEach(() => {
      vi.clearAllMocks();
    });

    it('should grant access to captain role', async () => {
      const mockResult = { data: true, error: null };
      vi.mocked(supabase.rpc).mockResolvedValueOnce(mockResult);

      const result = await supabase.rpc('can_access_audit_logs', {
        user_uid: 'captain-uid'
      });

      expect(supabase.rpc).toHaveBeenCalledWith('can_access_audit_logs', {
        user_uid: 'captain-uid'
      });
      expect(result.data).toBe(true);
      expect(result.error).toBeNull();
    });

    it('should deny access to officer role', async () => {
      const mockResult = { data: false, error: null };
      vi.mocked(supabase.rpc).mockResolvedValueOnce(mockResult);

      const result = await supabase.rpc('can_access_audit_logs', {
        user_uid: 'officer-uid'
      });

      expect(result.data).toBe(false);
      expect(result.error).toBeNull();
    });

    Implement similar patterns for all 5 test cases.
    Clearly document the security model: Captain/Admin = true, Officer/None = false.

    Run npm run test:run to confirm all tests pass.
  </action>
  <verify>npm run test:run shows all 5 tests passing; access control behavior verified</verify>
  <done>Tests pass with mocked Supabase client responses</done>
</task>

<task type="auto">
  <name>REFACTOR: Clean up test organization if needed</name>
  <files>tests/unit/database/can_access_audit_logs.test.ts</files>
  <action>
    Review test file for cleanup opportunities:

    1. Group tests by access level (granted vs denied vs errors)
    2. Add comments explaining the Captain/Admin-only security decision
    3. Extract common test data (roles) to constants if reused
    4. Ensure consistent assertion style across tests

    Only refactor if obvious improvements exist.

    Run npm run test:run after refactoring to confirm tests still pass.
  </action>
  <verify>npm run test:run still passes; code is more readable/maintainable</verify>
  <done>Test code is clean and maintainable with clear security documentation</done>
</task>

</tasks>

<verification>
After completion, verify:
1. tests/unit/database/can_access_audit_logs.test.ts exists with 5 test cases
2. All tests pass (npm run test:run)
3. Tests verify Captain and Admin roles have access (true)
4. Tests verify Officer and no-role users are denied (false)
5. Mocks are cleared between tests
</verification>

<success_criteria>
1. Unit tests exist for can_access_audit_logs function
2. Tests verify RPC call pattern with correct user_uid parameter
3. Tests confirm Captain/Admin-only access restriction
4. All tests pass when executed with npm run test:run
</success_criteria>

<output>
After completion, create `.planning/phases/02-performance/02-05-SUMMARY.md`
</output>
