# 2. Core Architecture

This document provides an in-depth look at the architectural principles that govern the BB Manager application. The architecture is designed to be robust, scalable, and resilient, with a strong emphasis on providing a seamless user experience, especially in low-connectivity environments.

### Core Principles

1.  **Offline-First**: The application must be fully functional without an internet connection. The UI should be fast and responsive, interacting primarily with a local data source. This includes caching user roles for offline permission checks.
2.  **Stateless UI / Centralized State**: React components are kept as stateless as possible. Global state (user, active section, data, user role) is managed by the root `App.tsx` component and custom hooks, then passed down via props.
3.  **Data Abstraction**: The UI should not be concerned with where data comes from (local cache or remote server). The `services/db.ts` file acts as a single source of truth for all data operations, abstracting away the complexity of managing two data sources.
4.  **Data Integrity & Security**: All data changes must be durable. Actions taken offline are queued and synced reliably. Security is enforced primarily through **PostgreSQL Row Level Security (RLS)** policies on the Supabase backend, ensuring users can only access data relevant to their role and assigned sections.

---

### Offline-First Strategy

The offline-first approach is the cornerstone of this application's architecture. It ensures a consistent and reliable user experience, which is critical for an app intended for use in locations with potentially poor Wi-Fi.

**Data Flow Diagram:**

```
[ User Action ] -> [ React Component ] -> [ services/db.ts ] -> [ services/offlineDb.ts (IndexedDB) ]
       ^                                                                          |
       |                                                                          | (If online)
       +--- [ UI Update (Local) ] <------------------------------------------------+
                                                                                    |
                                                                                    v
       ^------------------------- [ UI Update (Remote) ] <--- [ Event Listener ] <- [ Supabase Sync ]
```

1.  **App Shell Caching**: The Service Worker (`sw.js`) pre-caches the main application shell (HTML, JS, manifest). This makes the initial load nearly instantaneous on subsequent visits.
2.  **Local Database (IndexedDB)**: `services/offlineDb.ts` sets up and manages a local IndexedDB database. This is the primary data source for the entire application. All `Boy` records, `AuditLog` entries, and `UserRole` entries are stored here.
3.  **UI Interaction**: When a user views a list of members or edits a mark, the React UI is reading from and writing to IndexedDB.
4.  **Pending Writes Queue**: When a write operation (create, update, delete) occurs, it is immediately applied to the local IndexedDB. Simultaneously, a record of this operation is added to a special `pending_writes` store. This queue acts as a durable log of all changes that have not yet been saved to the central Supabase database.
5.  **Event-Driven UI Refresh**: When the background sync successfully fetches new data from Supabase, it dispatches a custom browser event (e.g., `datarefreshed`, `logsrefreshed`, `userrolerefresh`). The root `App` component listens for these events and triggers a data refresh in the UI.

---

### Data Synchronization

Synchronization is the process of reconciling the local data with the remote Supabase database.

-   **Trigger**: The `syncPendingWrites()` function in `services/db.ts` is called on initial app load and whenever the browser detects an internet connection (via the `online` event).
-   **Process**:
    1.  The function reads all pending operations from the `pending_writes` queue.
    2.  It executes each operation against the Supabase PostgreSQL database using the Supabase client.
    3.  **Only upon a successful execution of all writes**, the `pending_writes` queue in IndexedDB is cleared. If any operation fails, the queue remains intact, and the sync will be re-attempted later.

-   **Intelligent Cache Updates**: When fetching data from Supabase to update the local cache, the application performs an intelligent **deep comparison** between the fresh data and the cached data. An update to the local cache (and the subsequent UI refresh) is only triggered if the data has *actually changed*.

-   **Offline ID Handling**: When a new record is created offline, a temporary, unique ID (`offline_...`) is generated. The `syncPendingWrites` function handles replacing this temporary ID with the permanent UUID generated by PostgreSQL upon successful insertion.

---

### User Roles, Sections, and Security

The application implements a robust user management system enforced by PostgreSQL Row Level Security (RLS).

-   **User Roles (`user_roles` table)**: Each user is assigned a `UserRole` (Admin, Captain, Officer, Pending) and an array of `sections` they are authorized to access. This information is stored in a global Supabase table and locally cached in IndexedDB.
-   **RLS Enforcement**: The database uses RLS policies to ensure:
    *   A user can only read/write data in the `company_boys` table if their `user_roles.sections` array includes 'company'.
    *   Only Admins and Captains can read/write to the `user_roles` table (excluding a user reading their own role).
    *   Only Admins and Captains can access the audit logs.
-   **Pending Approval**: New users are automatically assigned the 'pending' role via a PostgreSQL trigger (`handle_new_user`) upon signup. They are blocked from accessing the main app until an Admin or Captain uses the Global Settings page to approve them and assign a proper role and sections.
-   **Secure Deletion (Edge Function)**: Deleting a user account is handled by a secure **Supabase Edge Function** (`delete-user`). This function runs server-side with the Service Role key, allowing it to delete the user from Supabase Auth, which is not possible from the client-side application.

---

### Multi-Section Support

Data for the **Company Section** and **Junior Section** is kept completely separate and isolated.

-   The `activeSection` variable is used by service functions in `db.ts` to dynamically determine which database tables to use (e.g., `company_boys` vs. `junior_boys`).
-   The UI (`SectionSelectPage`) uses the user's assigned `sections` array to visually restrict access for Officers, ensuring they only attempt to load data they are authorized to see.